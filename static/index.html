<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>3D Head Tracking</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            color: white; font-family: monospace;
            font-size: 14px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 5px;
        }

        /* ğŸ”¥ æ–°å¢ï¼šæ¸…é™¤æŒ‰é’® */
        #clearBtn {
            position: absolute;
            top: 45px;
            left: 10px;
            z-index: 10;
            background: #ff4444;
            border: none;
            padding: 6px 12px;
            color: white;
            font-family: monospace;
            border-radius: 4px;
            cursor: pointer;
        }
        #clearBtn:hover {
            background: #cc0000;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
        }
    }
    </script>
</head>
<body>

<div id="info">Waiting for data...</div>
<button id="clearBtn">Clear</button>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ===== åœºæ™¯åŸºç¡€è®¾ç½® =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.01,
        500
    );
    camera.position.set(2, 2, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AxesHelper(2.0));
    scene.add(new THREE.GridHelper(10, 10, 0x444444, 0x222222));

    let line = null;

    // ===== æ•°æ®é¢„å¤„ç†å‡½æ•° =====
    function processData(rawPoints) {
        if (!rawPoints || rawPoints.length === 0) return [];

        const scale = 3.0; // è½¨è¿¹æ”¾å¤§æ¯”ä¾‹
        let origin = null;
        const processed = [];

        for (let p of rawPoints) {
            const pos = p.position || p;
            if (!Array.isArray(pos) || pos.length < 3) continue;

            const v = new THREE.Vector3(pos[0], pos[1], pos[2]);

            if (!origin) origin = v.clone();

            // ç›¸å¯¹ + æ”¾å¤§
            const rel = v.clone().sub(origin).multiplyScalar(scale);
            processed.push(rel);
        }

        return processed;
    }

    // ===== æ›´æ–°è½¨è¿¹ =====
    function updateTrajectory(points) {
        if (line) {
            scene.remove(line);
            line.geometry.dispose();
            line.material.dispose();
            line = null;
        }

        if (!points || points.length === 0) {
            document.getElementById("info").innerText = "Points: 0";
            return;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setFromPoints(points);

        line = new THREE.Line(
            geometry,
            new THREE.LineBasicMaterial({ color: 0x00ffaa })
        );

        scene.add(line);
        document.getElementById("info").innerText = `Points: ${points.length}`;
    }

    // ===== æ¸…ç©ºæŒ‰é’®åŠŸèƒ½ =====
    document.getElementById("clearBtn").onclick = async () => {
        try {
            const res = await fetch("/clear", { method: "POST" });
            if (!res.ok) throw new Error("Clear API failed");

            updateTrajectory([]); // æ¸…é™¤å‰ç«¯è½¨è¿¹
            document.getElementById("info").innerText = "Cleared";

        } catch (err) {
            console.error(err);
            document.getElementById("info").innerText = "Clear failed";
        }
    };

    // ===== è½®è¯¢æœåŠ¡å™¨ =====
    async function fetchTrajectory() {
        try {
            const res = await fetch("/trajectory");
            const raw = await res.json();

            const cleaned = processData(raw);
            updateTrajectory(cleaned);

        } catch (err) {
            console.error(err);
            document.getElementById("info").innerText = "Error connecting to server";
        }
    }

    setInterval(fetchTrajectory, 200);

    // ===== æ¸²æŸ“å¾ªç¯ =====
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // ===== è‡ªé€‚åº”çª—å£ =====
    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>